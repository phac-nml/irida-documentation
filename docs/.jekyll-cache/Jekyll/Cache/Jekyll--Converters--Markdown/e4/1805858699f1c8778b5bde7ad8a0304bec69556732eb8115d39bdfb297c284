I"´´<h1 class="no_toc" id="irida-development-primer">IRIDA Development Primer</h1>

<p>This guide is for new developers to the IRIDA project to get a basic understanding of the layout of the project.  Before getting started, new developers should read our <a href="https://github.com/phac-nml/irida/blob/development/CONTRIBUTING.md">Contributing</a> page.</p>

<ul id="markdown-toc">
  <li><a href="#important-links" id="markdown-toc-important-links">Important links</a></li>
  <li><a href="#languages-and-libraries" id="markdown-toc-languages-and-libraries">Languages and Libraries</a></li>
  <li><a href="#development-platform" id="markdown-toc-development-platform">Development platform</a></li>
  <li><a href="#quick-start-development-requirements" id="markdown-toc-quick-start-development-requirements">Quick start development requirements</a></li>
  <li><a href="#running-and-building-irida" id="markdown-toc-running-and-building-irida">Running and building IRIDA</a>    <ul>
      <li><a href="#running-a-development-server" id="markdown-toc-running-a-development-server">Running a development server</a></li>
      <li><a href="#spring-profiles" id="markdown-toc-spring-profiles">Spring profiles</a>        <ul>
          <li><a href="#basic-profiles" id="markdown-toc-basic-profiles">Basic profiles</a></li>
          <li><a href="#advanced-profiles" id="markdown-toc-advanced-profiles">Advanced profiles</a></li>
          <li><a href="#testing-profiles" id="markdown-toc-testing-profiles">Testing profiles</a></li>
        </ul>
      </li>
      <li><a href="#running-irida-tests-locally" id="markdown-toc-running-irida-tests-locally">Running IRIDA tests locally</a></li>
      <li><a href="#building-irida-for-release" id="markdown-toc-building-irida-for-release">Building IRIDA for release</a></li>
      <li><a href="#building-irida-documentation" id="markdown-toc-building-irida-documentation">Building IRIDA documentation</a></li>
    </ul>
  </li>
  <li><a href="#irida-codebase" id="markdown-toc-irida-codebase">IRIDA Codebase</a>    <ul>
      <li><a href="#java-classpath" id="markdown-toc-java-classpath">Java classpath</a></li>
      <li><a href="#irida-security" id="markdown-toc-irida-security">IRIDA Security</a></li>
    </ul>
  </li>
  <li><a href="#building-new-features" id="markdown-toc-building-new-features">Building new features</a>    <ul>
      <li><a href="#github-issues" id="markdown-toc-github-issues">GitHub Issues</a></li>
      <li><a href="#informing-users-of-changes" id="markdown-toc-informing-users-of-changes">Informing users of changes</a></li>
      <li><a href="#irida-tests" id="markdown-toc-irida-tests">IRIDA tests</a></li>
      <li><a href="#database-updates" id="markdown-toc-database-updates">Database Updates</a></li>
      <li><a href="#documentation" id="markdown-toc-documentation">Documentation</a></li>
    </ul>
  </li>
  <li><a href="#version-control" id="markdown-toc-version-control">Version control</a></li>
</ul>

<h2 class="no_toc" id="document-history">Document History</h2>

<ul>
  <li>Aug 18, 2017: Document creation.</li>
</ul>

<h2 id="important-links">Important links</h2>
<ul>
  <li>IRIDA GitHub - <a href="https://github.com/phac-nml/irida">https://github.com/phac-nml/irida</a></li>
  <li>Documentation site - <a href="https://irida.corefacility.ca/documentation/">https://irida.corefacility.ca/documentation/</a></li>
  <li>Contributing guide - <a href="https://github.com/phac-nml/irida/blob/development/CONTRIBUTING.md">https://github.com/phac-nml/irida/blob/development/CONTRIBUTING.md</a></li>
  <li>Public information website - <a href="https://irida.ca">https://irida.ca</a></li>
</ul>

<h2 id="languages-and-libraries">Languages and Libraries</h2>

<p>IRIDA is a Java application developed using Java 11.</p>

<h4 class="no_toc" id="spring-framework">Spring framework</h4>

<p>Documentation: <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/spring-framework-reference/">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/spring-framework-reference/</a></p>

<p>IRIDA uses the Spring Framework as the main backbone of the application.  Spring is used to assist with many of the main functions of the application including configuration, dependency injection, MVC, REST API, Java persistance API management, and more.</p>

<p>For a better understanding of how Spring works, it‚Äôs recommended that IRIDA developers attend a <em>Core Spring Training</em> course <a href="https://pivotal.io/training/courses/core-spring-training">https://pivotal.io/training/courses/core-spring-training</a>.</p>

<h4 class="no_toc" id="apache-maven">Apache Maven</h4>

<p>Documentation: <a href="http://maven.apache.org/guides/">http://maven.apache.org/guides/</a></p>

<p>IRIDA uses Apache Maven for dependency management and build automation.  Maven allows developers to specify dependencies for a Java application and Maven will handle downloading all necessary required packages and ensuring they‚Äôre available for developers on the Java classpath.  It also allows you to specify build lifecycles to automate packaging an application for distribution or execute code for development.</p>

<p>Maven settings and dependencies can generally be found in the <code>pom.xml</code> file in the IRIDA root directory.</p>

<h4 class="no_toc" id="hibernate">Hibernate</h4>

<p>Documentation:<a href="http://hibernate.org/orm/documentation/4.3/">http://hibernate.org/orm/documentation/4.3/</a></p>

<p>Hibernate is used to map Java objects to database tables without the need for writing extra database code.  IRIDA uses hibernate through the Java Persistence API abstraction.</p>

<h4 class="no_toc" id="liquibase">Liquibase</h4>

<p>Documentation: <a href="http://www.liquibase.org/documentation/index.html">http://www.liquibase.org/documentation/index.html</a></p>

<p>Liquibase is used to manage IRIDA‚Äôs relational database change management.  Any time a change is made to IRIDA‚Äôs production database schema, Liquibase is used to perform the change.  See the <a href="#database-updates">Database Updates</a> section for more.</p>

<h4 class="no_toc" id="galaxy">Galaxy</h4>

<p>Documentation: <a href="https://docs.galaxyproject.org/en/master/index.html">https://docs.galaxyproject.org/en/master/index.html</a></p>

<p>Galaxy is used as IRIDA‚Äôs analysis workflow engine.  Analysis pipelines must be developed as Galaxy pipelines to integrate with IRIDA‚Äôs workflow system.  See the <a href="/administrator/galaxy/">Galaxy Setup</a> documentation for Galaxy installation and the <a href="/developer/tools/">Tool Development</a> documentation for building tools for IRDIA.</p>

<h4 class="no_toc" id="other-important-libraries">Other important libraries</h4>

<ul>
  <li>Thymeleaf - Web interface templating - <a href="http://www.thymeleaf.org/documentation.html">http://www.thymeleaf.org/documentation.html</a></li>
  <li>JQuery - Javascript libraries - <a href="https://api.jquery.com/">https://api.jquery.com/</a></li>
  <li>AngularJS - Javascript libraries and templating - <a href="https://docs.angularjs.org/api">https://docs.angularjs.org/api</a></li>
  <li>Jekyll - Documentation build - <a href="http://jekyllrb.com/docs/home/">http://jekyllrb.com/docs/home/</a></li>
</ul>

<h2 id="development-platform">Development platform</h2>

<p>The development platform used by most IRIDA developers is the <a href="https://eclipse.org/ide/">Eclipse</a> IDE.</p>

<p>The following plugins are recommended:</p>

<ul>
  <li>Eclipse EGit - Git integration.  Helps by showing changes made to your codebase.</li>
  <li>Eclipse m2e - Maven integration.  Helps build your Maven project.</li>
</ul>

<p>The following code formatting file should be imported into Eclipse for consistency between developers: <a href="irida-code-format.xml">IRIDA eclipse code format</a></p>

<h2 id="quick-start-development-requirements">Quick start development requirements</h2>

<p>An (incomplete) set of instructions for getting the IRIDA service layer and web front up and running for development on your Linux machine.  To include Galaxy and all the pipeline requirements, see the main IRIDA documentation.</p>

<ul>
  <li>Clone IRIDA from the IRIDA <a href="https://github.com/phac-nml/irida">GitHub</a>.</li>
  <li>Install the following dependencies from your chosen package manager:
    <ul>
      <li>MariaDB</li>
      <li>Java 11 JDK</li>
      <li>Apache Maven</li>
    </ul>
  </li>
  <li>Run the library installation script in the <code>lib/</code> directory:</li>
</ul>

<div class="highlight"><pre><code>cd irida/lib/
./install-libs.sh
</code></pre></div>
<ul>
  <li>Create a test database in MariaDB with the name <code>irida_test</code> and user <code>test</code> with password <code>test</code>.</li>
  <li>Create a second test database in MariaDB with the name <code>irida_integration_test</code> and user <code>test</code> with password <code>test</code> (for running local integration tests).</li>
</ul>

<div class="highlight"><pre><code class="language-bash"><span class="c1"># Setup databases example</span>
<span class="c1"># These steps may differ depending on your installation</span>

<span class="c1"># log into mysql as root</span>
sudo mysql -u root</code></pre></div>

<div class="highlight"><pre><code class="language-SQL"><span class="o">#</span> <span class="k">create</span> <span class="n">databases</span>
<span class="k">create</span> <span class="k">database</span> <span class="n">irida_test</span><span class="p">;</span>
<span class="k">create</span> <span class="k">database</span> <span class="n">irida_integration_test</span><span class="p">;</span>

<span class="o">#</span> <span class="n">give</span> <span class="n">test</span> <span class="k">user</span> <span class="k">access</span>
<span class="k">grant</span> <span class="k">all</span> <span class="k">privileges</span> <span class="k">on</span> <span class="n">irida_test</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">&#39;test&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">&#39;test&#39;</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">all</span> <span class="k">privileges</span> <span class="k">on</span> <span class="n">irida_integration_test</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">&#39;test&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">&#39;test&#39;</span><span class="p">;</span>

<span class="o">#</span> <span class="n">exit</span>
<span class="n">quit</span></code></pre></div>

<div class="highlight"><pre><code class="language-bash"><span class="c1"># check that test user has access</span>
mysql -u <span class="nb">test</span> -p irida_test</code></pre></div>

<p>From here you should be able to run the IRIDA service layer, REST API, and web UI using Jetty.</p>

<h2 id="running-and-building-irida">Running and building IRIDA</h2>

<h4 id="running-a-development-server">Running a development server</h4>

<p>An IRIDA development server can be run with the <code>run.sh</code> script available in the project root directory.  The script has one option <code>--create-db</code>.  Using this option will automatically drop and recreate the database using test data. A newly created development database will contain the profile <code>admin</code>, with password <code>password1</code>, that can be used to log in to IRIDA.</p>

<p>Running the <code>run.sh</code> without arguments script is equivalent to running:</p>

<div class="highlight"><pre><code class="language-bash">mvn clean jetty:run -Dspring.profiles.active<span class="o">=</span>dev</code></pre></div>

<p>Any arguments added after <code>run.sh</code> will be proxied to the <code>mvn ...</code> command.</p>

<h4 id="spring-profiles">Spring profiles</h4>

<p>Spring allows us to set profiles in the application that can be used to set up certain services for running in different environments.</p>

<h5 id="basic-profiles">Basic profiles</h5>
<ul>
  <li><code>prod</code> - Production mode.
    <ul>
      <li>Hibernate will not be allowed to make changes to the database schema.</li>
      <li>Database will be managed by Liquibase.</li>
      <li>Attempt to connect to Galaxy to run workflows</li>
      <li>Run all scheduled tasks such as NCBI uploads, data synchronization, etc.</li>
    </ul>
  </li>
  <li><code>dev</code> - Development mode.
    <ul>
      <li>Hibernate to attempt to update the IRIDA database as you make code changes.</li>
      <li>No galaxy connection.</li>
      <li>Run only the file processing scheduled task.</li>
    </ul>
  </li>
</ul>

<h5 id="advanced-profiles">Advanced profiles</h5>

<p>The advanced profiles allow you to configure your server to run specific components of the IRIDA application.  The different profiles enable specific scheduled tasks which are used to run many of IRIDA‚Äôs analysis, processing, or data transfer tools.  For more information on setting up an IRIDA server to run in multi-server mode, see the <a href="../../administrator/web/#multi-web-server-configuration">installation documentation</a>.</p>

<ul>
  <li><code>web</code> - Run the IRIDA user interface and REST API web application servers.</li>
  <li><code>email</code> - Run the email subscription service.  This will send email digests out to users on a scheduled basis.</li>
  <li><code>analysis</code> - Run the IRIDA analysis engine.  This profile launches and monitors progress of all analysis pipelines in IRIDA.</li>
  <li><code>processing</code> - File processing pipeline for uploaded sequencing data.</li>
  <li><code>sync</code> - Synchronizing remote projects.</li>
  <li><code>ncbi</code> - Uploading data to NCBI.</li>
</ul>

<h5 id="testing-profiles">Testing profiles</h5>
<ul>
  <li><code>it</code> - Integration test.
    <ul>
      <li>Liquibase used for database setup, but should only be used for integration testing.</li>
    </ul>
  </li>
  <li><code>test</code> - This profile is generally used when testing connecting to Galaxy.</li>
</ul>

<p>When running IRIDA from the command line, a profile can be set by adding the following parameter:</p>

<div class="highlight"><pre><code class="language-bash">-Dspring.profiles.active<span class="o">=</span>YOURPROFILE</code></pre></div>

<h4 id="running-irida-tests-locally">Running IRIDA tests locally</h4>

<p>While Travis CI on GitHub runs all IRIDA‚Äôs testing on every git push, it is often useful to run IRIDA‚Äôs test suite locally for debugging or development.  IRIDA‚Äôs test suite can be run with Maven using the <code>test</code> and <code>verify</code> goals.</p>

<p>See the <a href="#irida-tests">IRIDA tests</a> section for more on how IRIDA‚Äôs tests are developed.</p>

<h5 class="no_toc" id="unit-tests">Unit tests</h5>

<p>IRIDA‚Äôs unit tests can be run with the following command:</p>

<div class="highlight"><pre><code class="language-bash">mvn clean <span class="nb">test</span></code></pre></div>

<p>Maven will download all required dependencies and run the full suite of unit tests.  This will take a couple minutes and a report stating what tests passed and failed will be presented.</p>

<h5 class="no_toc" id="integration-tests">Integration tests</h5>

<p>IRIDA has 5 integration test profiles which splits the integration test suite into functional groups.  This allows Travis CI to run the tests in parallel, and local test executions to only run the required portion of the test suite.  The 5 profiles are the following:</p>

<ul>
  <li><code>service_testing</code> - Runs the service layer and repository testing.</li>
  <li><code>ui_testing</code> - Integration tests for IRIDA‚Äôs web interface.</li>
  <li><code>rest_testing</code> - Tests IRIDA‚Äôs REST API.</li>
  <li><code>galaxy_testing</code> - Runs tests for IRIDA communicating with Galaxy.  This profile will automatically start a test galaxy instance to test with.</li>
  <li><code>galaxy_pipeline_testing</code> - Runs tests for running a pipeline with Galaxy.  This profile will automatically start a test galaxy instance to test with.</li>
</ul>

<p>See the <code>&lt;profiles&gt;</code> section of the <code>pom.xml</code> file to see how the profiles are defined.</p>

<p>As the integration tests simulate a running IRIDA installation, in order to run any integration test the requirements needed to run a production IRIDA server must be installed on your development machine.  The test profiles can each by run directly with <code>mvn verify</code>, but additional setup may be required for the tests to work properly.  To perform this setup and run all the tests, the <code>run-tests.sh</code> script can be used.  To run a test profile with <code>run-tests.sh</code> please run the following:</p>

<div class="highlight"><pre><code class="language-bash">./run-tests.sh &lt;TEST PROFILE&gt;</code></pre></div>

<p>This will clean and setup an empty database for IRIDA on the local machine named <strong>irida_integration_test</strong>.  This will also, for the Galaxy test profile, start up a Galaxy IRIDA testing Docker image running on <a href="http://localhost:48889">http://localhost:48889</a> and destory this Docker image afterwards (you can skip destorying the Docker image by passing <code>--no-kill-docker</code> to this script).  In order to not overwrite the database <strong>irida_integration_test</strong> you may pass the name of a new database as:</p>

<div class="highlight"><pre><code class="language-bash">./run-tests.sh -d &lt;DATABASE&gt; &lt;TEST PROFILE&gt;</code></pre></div>

<p>This assumes that the user <strong>test</strong> has been given all permissions to <code>&lt;DATABASE&gt;</code> (e.g., in SQL <code>grant all privileges on &lt;DATABASE&gt;.* to 'test'@'localhost';</code>).</p>

<p>As an example of how to run the IRIDA integration tests:</p>

<div class="highlight"><pre><code>./run-tests.sh galaxy_testing
</code></pre></div>

<p>This will:</p>

<ol>
  <li>Clean/re-build the IRIDA database on <code>irida_integration_test</code> (use <code>-d</code> to override).</li>
  <li>Remove any previous Docker images from previous tests (named <em>irida-galaxy-test</em>).</li>
  <li>Start up a new Docker image with Galaxy running on <a href="http://localhost:48889">http://localhost:48889</a>.</li>
  <li>Run IRIDA <code>galaxy_testing</code> integration test profile.</li>
  <li>Remove Docker image on <a href="http://localhost:48889">http://localhost:48889</a>.</li>
</ol>

<p>Additional Maven parameters can be passed to <code>run-tests.sh</code>.  In particular, individual test classes can be run using <code>-Dit.test=ca.corefacilty.bioinformatics.irida.TheTestClass</code>. For example:</p>

<div class="highlight"><pre><code class="language-bash">./run-tests.sh rest_testing -Dit.test<span class="o">=</span>ca.corefacility.bioinformatics.irida.web.controller.test.integration.analysis.RESTAnalysisSubmissionControllerIT</code></pre></div>

<h4 id="building-irida-for-release">Building IRIDA for release</h4>

<p>Run the following:</p>

<div class="highlight"><pre><code class="language-bash">mvn clean package -DskipTests</code></pre></div>

<p>This will create the <code>.war</code> and <code>.zip</code> files for IRIDA release under the <code>target/</code> directory.</p>

<h4 id="building-irida-documentation">Building IRIDA documentation</h4>

<p>IRIDA documentation can be found in the <code>doc/</code> directory in the IRIDA root directory.  IRIDA‚Äôs documentation is built using <a href="http://jekyllrb.com/docs/home/">Jekyll</a>.  Jekyll allows us to write documentation in Markdown format and it will convert the pages to HTML for releasing to the web.  The documentation at <a href="http://irida.corefacility.ca/documentation">http://irida.corefacility.ca/documentation</a> is all generated using this tool.</p>

<p>To test any documentation changes, you can <code>cd</code> into the <code>doc/</code> directory and run the following command:</p>

<div class="highlight"><pre><code>jekyll serve
</code></pre></div>

<p>This command will read the <code>_config.yml</code> file in the directory for configuration settings, then serve the built documentation at http://localhost:4000.  As you make changes to documentation files it will automatically regenerate the documentation and reload its webserver.</p>

<p>To build the documentation for release, you can run the following:</p>

<div class="highlight"><pre><code class="language-bash">mvn clean site</code></pre></div>

<p>This will build the documentation HTML files into <code>doc/_site</code>.  That directory can be placed onto a web server for release.</p>

<h2 id="irida-codebase">IRIDA Codebase</h2>

<p>IRIDA is organized as a fairly classic Java web application.  All main source can be found in the <code>src/main/</code> path.  Test code will be in <code>src/test/</code></p>

<ul>
  <li><code>src/main/java</code> - IRIDA‚Äôs Java source code.  All Java code for the main application is in this root.</li>
  <li><code>src/main/webapp</code> - Web application code.  All web templates, Javascript, CSS, etc. is found here.</li>
  <li><code>src/main/resources</code> - Configuration files, database update files, internationalization, and other scripts which are outside of the other <code>src/main</code> directories.</li>
  <li><code>src/test/java</code> - Java test files.  IRIDA uses JUnit for testing.  See the <a href="#irida-tests">IRIDA tests</a> section for more.</li>
  <li><code>src/test/resources</code> - Additional files required for IRIDA testing.  These will generally be database files, test data, and test configuration.</li>
</ul>

<h3 id="java-classpath">Java classpath</h3>

<p>All files are found under the <code>ca.corefacility.bioinformatics.irida</code> package root.</p>

<ul>
  <li><code>config</code> - Configuration classes.  All Spring application config, web config, Maven config, and scheduled task configuration can be found here.</li>
  <li><code>database.changesets</code> - Java Liquibase changesets.  See more about our liquibase usage in the <a href="#database-updates">Database Updates section</a>.</li>
  <li><code>events</code> - Classes here handle the <code>ProjectEvent</code> structure in IRIDA.  These are the messages you can find on the IRIDA dashboard and project recent activity pages.</li>
  <li><code>exceptions</code> - Java <code>Exception</code> classes written for IRIDA.</li>
  <li><code>model</code> - IRIDA uses MVC.  These are the model classes which are persisted into the database using <a href="http://projects.spring.io/spring-data-jpa/">Spring Data JPA</a> and Hibernate.</li>
  <li><code>pipeline.upload</code> - Classes used to communicate workflows, libraries, and histories to Galaxy.</li>
  <li><code>processing</code> - IRIDA‚Äôs file processing chain.  This contains classes used when processing files uploaded to IRIDA such as unzipping, FastQC, and quality control.</li>
  <li><code>repositories</code> - Repositories used for communicating with IRIDA‚Äôs database.  These classes generally use <a href="http://projects.spring.io/spring-data-jpa/">Spring Data JPA</a> for communicating with the database.</li>
  <li><code>ria</code> - ‚ÄúRich Internet Application‚Äù, this is where the controller code and all Java code for the web interface is found.</li>
  <li><code>security</code> - IRIDA‚Äôs security layer.  You‚Äôll mostly find <a href="https://projects.spring.io/spring-security/">Spring Security</a>  classes within.  See more in the <a href="#irida-security">security</a> section.</li>
  <li><code>service</code> - IRIDA‚Äôs service layer.  Here you‚Äôll find the business logic for reading, saving, and manipulating data.</li>
  <li><code>util</code> - General utility classes.  These are generally developer tools that don‚Äôt fit anywhere else in the class structure.</li>
  <li><code>validators</code> - Validation classes used to verify data being saved in the database is correct.</li>
  <li><code>web</code> - IRIDA‚Äôs REST API.</li>
</ul>

<h3 id="irida-security">IRIDA Security</h3>

<p>IRIDA uses <a href="https://projects.spring.io/spring-security/">Spring Security</a> extensively to control access and authentication in the platform.  The majority of the security resides at the service layer of the application, but some security functions can be found elsewhere in the codebase.</p>

<p>Method security is generally handled by adding Spring security annotations to methods.  These annotations can have a number of different forms.</p>

<h4 class="no_toc" id="role-based-security">Role based security</h4>

<p>The <code>@PreAuthorize</code> annotation is used for the majority of security functions.  This annotation outlines the conditions which must be met in order for a user to run a given method.  If the user does not meet the conditions, an <code>AccessDeniedException</code> will be thrown.</p>

<p>The simplest case for this annotation uses the <code>hasRole('ROLE')</code> format.  In this case it is checking whether the logged in user has a given system role.  For example the following block will check if the logged in user is an admin:</p>

<div class="highlight"><pre><code class="language-java"><span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">(){}</span></code></pre></div>

<h4 class="no_toc" id="custom-permission-classes">Custom permission classes</h4>

<p>In cases where role-based security isn‚Äôt enough, Spring Security allows us to write custom permissions classes to test whether a user can perform a function.  For most cases in IRIDA, this is checking whether a user has access to a given object in the database (Project, Sample, SequencingObject, etc.) to perform a given action (read, update, delete, etc.).  These custom permission classes can be found in the <code>ca.corefacility.bioinformatics.irida.security.permissions</code> classpath of the project.  Permissions must extend the <code>BasePermission</code> class and be annotated as a <code>@Component</code> to be wired into the IRIDA security layer.  See <code>ReadProjectPermission</code> for an example.</p>

<p>The meat of the permission lies in the <code>public boolean customPermissionAllowed(final Authentication authentication, final DOMAIN_OBJECT p)</code> method.  This method uses the logged in user‚Äôs authentication and a reference to the object they‚Äôre trying to access to try to determine if they should be able to perform the action.  Since the permission class is a Spring <code>@Component</code> it can wire in any repository layer elements needed to perform the test.  Once the <code>customPermissionAllowed</code> method determines if a user can perform the action, it returns <code>true</code>/<code>false</code> and the action will be approved or denied as such.</p>

<p>The second required method is <code>public String getPermissionProvided()</code>.  This method provides the security system a name for the permission.  This name will be used in the <code>@PreAuthorize</code> or <code>@PostFilter</code> annotations using Spring Expression Language.</p>

<p>When a permission class implements both of these methods, it can be used in Spring security annotations.  For example if we had the permission <code>ReadProjectPermission</code> named <code>canReadProject</code>, we could use it on a method in the following fashion:</p>

<div class="highlight"><pre><code class="language-java"><span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">&quot;hasPermission(#project, &#39;canReadProject&#39;)&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">Project</span> <span class="n">project</span><span class="o">){}</span></code></pre></div>

<p>This block does the following:</p>

<ol>
  <li>Loads the <code>ReadProjectPermission</code> class based on the <code>canReadProject</code> name</li>
  <li>Passes the <code>project</code> parameter into the <code>customPermissionAllowed</code> method of the permission class as it‚Äôs identified by the <code>#project</code> parameter in the annotation.</li>
  <li>Executes the <code>customPermissionAllowed</code> method to determine if the logged in user has access to do the requested action.</li>
  <li>If the user should have access, the method runs as normal.  If not, <code>AccessDeniedException</code> is thrown.</li>
</ol>

<p>In addition to passing in domain objects, the permission classes are able to read objects by their ID.  For example if we have the following block:</p>

<div class="highlight"><pre><code class="language-java"><span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">&quot;hasPermission(#projectId, &#39;canReadProject&#39;)&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">Long</span> <span class="n">projectId</span><span class="o">){}</span></code></pre></div>

<p>Passing the <code>projectId</code> parameter to the annotation will read a <code>Project</code> from the database before passing to the <code>customPermissionAllowed</code> method.</p>

<p>These permission classes can also be used with the <code>@PostFilter</code> annotation.  This annotation runs after the method completes to see if the user has access to the output of the method.  This is generally used for methods returning collections of objects.  For example with the following block:</p>

<div class="highlight"><pre><code class="language-java"><span class="nd">@PostFilter</span><span class="o">(</span><span class="s">&quot;hasPermission(filterObject, &#39;canReadProject&#39;)&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Project</span><span class="o">&gt;</span> <span class="nf">doStuff</span><span class="o">(){}</span></code></pre></div>

<p>This code will ensure the logged in user can read each of the <code>Project</code>s being returned.  Any object they should not have access to will be pruned from the list.</p>

<h2 id="building-new-features">Building new features</h2>

<h4 id="github-issues">GitHub Issues</h4>

<p>Any time a request comes in from a user for a new feature, or a bug is found, an <em>issue</em> should be created on <a href="https://github.com/phac-nml/irida">GitHub</a>.  The IRIDA project uses GitHub‚Äôs issues list as it‚Äôs main project tracking system.  The issue should be documented as fully as possible with the following:</p>

<ul>
  <li>A general description of the problem/feature.</li>
  <li>What the expected functionality should be.</li>
  <li>Steps to reproduce the issue or how the feature should work.</li>
  <li>Who reported the bug or feature request.</li>
</ul>

<p>Once an issue is completed it should be referenced in a <a href="#pull-requests">pull request</a> in GitHub so the reviewer can know the full scope of the issue.</p>

<h3 id="informing-users-of-changes">Informing users of changes</h3>

<p>When adding new features we have a couple places we need to inform our users.  First is the <code>CHANGELOG.md</code> file found in the root of the project.  If you‚Äôve added a feature, fixed a bug, or made any changes worthwhile of telling IRIDA users, other IRIDA developers, or administrators they should be mentioned here.  Next is the <code>UPGRADING.md</code> guide.  This file is used to inform IRIDA system admins what steps need to be taken when upgrading from one version of IRIDA to another.  For example if you add anything to a configuration file, if there are changes which require an upgrade to the database, a workflow, or any dependencies, it should be mentioned here.</p>

<h3 id="irida-tests">IRIDA tests</h3>

<p>IRIDA uses JUnit for the majority of its testing.  To ensure the IRIDA codebase is performing as expected, when developing new features you should also write tests for the newly developed code.</p>

<p>IRIDA has 2 main types of tests:</p>

<h4 class="no_toc" id="unit-tests-1">Unit tests</h4>

<p>IRIDA unit tests are written entirely with JUnit and run with Maven Surefire.  Any classes or methods performing any sort of business logic should have unit tests written for them.  In general all test requirements should be mocked with Mockito, and tests should be written for expected behaviour, failure cases, and edge cases.  To mark a class as a unit test, the java file must be named with a <code>*Test.java</code> suffix.  For examples of existing IRIDA unit tests, see any classes under <code>src/test/java</code> class path <code>ca.corefacility.bioinformatics.irida.service.impl.unit</code>.</p>

<h4 class="no_toc" id="integration-tests-1">Integration tests</h4>

<p>IRIDA‚Äôs integration tests are again developed using JUnit and run with Maven Failsafe.  In addition to the unit tests described above, IRIDA‚Äôs integration tests verify that all components of the application work correctly together to produce the intended result.  Integration tests are generally written using the <code>SpringJUnit4ClassRunner</code> class which allows us to use a Spring application context and <code>@Autowired</code> to wire in test dependencies.  Mocking generally should not be used for dependencies in any integration tests.</p>

<p>As integration tests rely on the full application stack, database entries must be created at the beginning of each test.  To do this IRIDA uses the <a href="http://dbunit.sourceforge.net/">DBUnit</a> library to load test data into the database prior to every test, and to clear the database after the test is completed.  Test database files are generally created for each test class, but some are reused between test classes.  DBUnit test files are written in an easy XML format.</p>

<p>Tests for different parts of the application may use additional libraries such as:</p>

<ul>
  <li><a href="http://www.seleniumhq.org/">Selenium</a> for user interface testing.</li>
  <li><a href="http://rest-assured.io/">REST-assured</a> for REST API testing.</li>
</ul>

<p>Refer to similar tests for examples of writing tests for the UI, REST API, etc.</p>

<p>To mark a class as a unit test, the java file must be named with a <code>*IT.java</code> suffix.  For examples of existing basic IRIDA integration tests, see classes under <code>src/test/java</code> class path <code>ca.corefacility.bioinformatics.irida.service.impl.integration</code>.</p>

<h3 id="database-updates">Database Updates</h3>

<p>While in development we use Hibernate to manage our database changes, in production we use <a href="http://www.liquibase.org/documentation/">Liquibase</a>.</p>

<p>Liquibase allows you to create changesets for an application‚Äôs database in incremental, database agnostic XML files.  In practice IRIDA requires MariaDB or MySQL, but it‚Äôs still worthwhile to use a tool to properly manage the updates.  Liquibase ensures that all changes to the database are performed in the correct order, and manages this by keeping track of a hashcode of the last applied changeset.  When IRIDA is started, liquibase runs first to check if there are new changesets to be applied, and also that the current state of the database is in the format that IRIDA will be expecting.</p>

<p>When we‚Äôre doing development, Liquibase is generally not used.  Instead we generally rely on Hibernate‚Äôs HBM2DDL module which allows us to directly make changes to the model classes and those changes will be reflected into the database.This can be enabled by running IRIDA in the <code>dev</code> Spring profile.  Additionally when running in the <code>dev</code> profile example data from <code>src/main/resounrces/ca/corefacility/bioinformatics/irida/sql</code> will be loaded into the database for test purpose.  Since HBM2DDL is not to be used in production environments, before creating a pull request you should add any changes that are made to the database to a new changeset XML file and test that the database is correctly built in the <code>prod</code> Spring profile.  If you‚Äôve modified any tables in the database it‚Äôs also worth testing whether those changes can be properly migrated from an existing production database.  To do this you should take a dump of a production IRIDA database, load the dump up on your development machine, and run a server in <code>prod</code> profile to ensure the database upgrades correctly.</p>

<p>You can find the existing Liquibase changeset files in <code>/src/manin/resounces/ca/corefacility/bioinformatics/irida/database/changesets</code>.</p>

<p>Sometimes database changes are too complex to be able to use Liquibase XML files.  Conveniently Liquibase also allows you to apply change sets using Java code.  This mode is not recommended to use very often as you don‚Äôt get some of the same change management features, but it‚Äôs useful when you have a difficult migration.  If you need to use a change set written in Java, place it under the <code>ca.corefacility.bioinformatics.irida.database.changesets</code> package.</p>

<h3 id="documentation">Documentation</h3>

<p>IRIDA has a number of sources of documentation.  For any user-facing changes, documentation should be added to the appropriate section of the user documentation under the <code>doc/</code> directory with instructions on how to use the new feature.</p>

<p>Developer documentation is also necessary for all Java classes, methods, code blocks, JavaScript, and any other code written for IRIDA.  In the Java portion of the IRIDA codebase, all methods and classes must have associated Javadoc.  To generate a Javadoc template for a method or class in Eclipse, type <code>/**</code> and press <code>&lt;Enter&gt;</code>.  A method/class description, all parameters, and return value should be documented.</p>

<h2 id="version-control">Version control</h2>

<p>The IRIDA project uses Git and <a href="https://github.com/phac-nml/irida">GitHub</a> for version control purposes.  External collaborators are welcomed to develop new features and should submit pull requests on IRIDA‚Äôs <a href="https://github.com/phac-nml/irida">GitHub</a> page.  See the <a href="https://github.com/phac-nml/irida/blob/development/CONTRIBUTING.md">Contributing</a> guide for more information on contributing to IRIDA.</p>

<h3 class="no_toc" id="branch-structure">Branch structure</h3>

<p>IRIDA‚Äôs branch structure is loosely based on the <a href="http://nvie.com/posts/a-successful-git-branching-model">GitFlow</a> branch model.  This model allows the team to develop multiple features in parallel without contaminating the main development branch, keeping pull requests sane, and allows for stable and patchable releases.</p>

<h4 class="no_toc" id="branches">Branches</h4>

<ul>
  <li><em>development</em> - This is the main running development branch.  It represents the latest features that have been developed by the team.  Features here should be kept in a state that they can be released at any time.</li>
  <li><em>master</em> - This is the release branch.  It should be kept at the latest stable release.</li>
  <li>feature branches - These should be created by the developers as they work on new additions to the application.  They should be branched off <em>development</em> and merged back once the feature is entirely complete and ready to release.</li>
  <li>hotfix branches - These branches will be created when there is an bug in the master branch which must be fixed immediately.  When these branches are complete they should be merged into both <em>development</em> and <em>master</em>.</li>
</ul>

<h4 class="no_toc" id="release-tags--versioning-scheme">Release tags &amp; versioning scheme</h4>

<p>IRIDA uses a <a href="https://calver.org/">CalVer</a> style versioning scheme.  This means the release version number is based on the year and month that it was released.  The scheme used is <code>YY.0M.minor</code>.  First segment is last 2 digits of the year, 2nd is 2 digit month, and 3rd is the number of bugfix release (optional).  For example a major release in January 2019 would be <code>19.01</code>.  If a bugfix release was performed for that version, it would be <code>19.01.1</code>.</p>

<p>Whenever code is merged into <em>master</em>, a release should be created.  To mark the release the person merging the code should create a git tag at the point of the merge.</p>

<div class="highlight"><pre><code class="language-bash">git tag YY.MM.minor</code></pre></div>

<p>Don‚Äôt forget to push the tag when you‚Äôre finished.</p>

<div class="highlight"><pre><code class="language-bash">git push --tags</code></pre></div>

<p>Once the tag has been pushed, the tag should have been automatically created on IRIDA‚Äôs <a href="https://github.com/phac-nml/irida">GitHub</a> site at <a href="https://github.com/phac-nml/irida/releases">https://github.com/phac-nml/irida/releases</a>.  This release will be created as a tag, but will not be a full release until release notes and release files are uploaded to <a href="https://github.com/phac-nml/irida">GitHub</a>.  To do this, click <em>Edit</em> next to the new tag, enter the details from the <code>CHANGELOG.md</code> file for this release, and upload the <code>.war</code> and <code>.zip</code> files for this release.</p>

<p>Example workflow:</p>

<p><img src="git-flow.png" alt="Git workflow" /></p>

<h4 class="no_toc" id="pull-requests">Pull requests</h4>

<p>Code is not to be merged into the <em>development</em> or <em>master</em> branches by the developer who wrote the code.  Instead a merge request should be made on <a href="https://github.com/phac-nml/irida">GitHub</a> and assigned to another developer on the project.  The reviewer should look over the code for issues, and anything that needs to be fixed should be mentioned in a comment in the merge request.  Once an issue has been fixed, the developer should push the changes to the merge request branch and mention the commit id in the comment so the reviewer can track the changes.</p>

<p>The reviewer of a merge request should ensure the following:</p>

<ul>
  <li>The new or updated functionality works as expected.  This includes properly handling error cases.</li>
  <li>Any new functionality is well documented in Javadoc, inline code comments, and in the user guide.</li>
  <li><em>CHANGELOG.md</em> and <em>UPGRADING.md</em> files are updated with necessary information.</li>
  <li>Any new features have appropriate unit and/or integration tests written and all tests are passing.</li>
  <li>New code is properly formatted using IRIDA‚Äôs code formatter file.</li>
  <li>New code does not produce any Java errors or warnings.  Acceptable warnings may include <em>deprecated</em> warnings for methods or classes which should be refactored out.  See Eclipse‚Äôs <em>Problems</em> panel for warnings produced.</li>
</ul>

<p>If a merge request is a fix for an issue that is being tracked in <a href="https://github.com/phac-nml/irida">GitHub</a>, the developer should mention the issue number in the merge request with the format <code>Fixes #1234</code> so that the merge request will be linked to the issue and it will be automatically closed once the merge is complete.</p>

<p>When the reviewer is satisfied with the state of the branch to be merged, they should merge it into the <em>development</em> branch in <a href="https://github.com/phac-nml/irida">GitHub</a> to close the request.</p>

:ET